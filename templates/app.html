<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Quality & Data Centers Map</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.3.1/dist/full.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">


    <style>
        html, body { height:100%; margin:0; font-family:'Inter',sans-serif; overflow:hidden; background:#111827; }
        #map {
            position: absolute;
            top: 120px; /* was 100px, give extra space */
            bottom: 0;
            right: 0;
            left: 0;
        }
<style>
.dc-icon i { color: white !important; }
html, body { height:100%; margin:0; font-family:'Inter',sans-serif; overflow:hidden; background:#111827; }
#map {
  position: absolute;
  top: 120px; /* was 100px, give extra space */
  bottom: 0;
  right: 0;
  left: 0;
}

        /* Monitor Panel */
        #monitor-panel {
            position:absolute; top:50%; left:10px; transform:translateY(-50%);
            background:rgba(30,41,59,0.95); color:#fff; padding:12px 16px;
            border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.5); z-index:500;
            font-size:0.9rem; display:flex; flex-direction:column; gap:4px;
        }

        /* Data Center Info Tab - Small */
        #dc-info-tab {
            position: absolute;
            top: calc(50% - 200px);
            left: 10px;
            transform: translateY(-50%);
            background: rgba(15, 42, 66, 0.95);
            color: #fff;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 510;
            width: 260px;          /* slightly bigger */
            display: none;
            flex-direction: column;
            gap: 10px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        #dc-info-tab div {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #dc-info-tab .dc-icon-small {
            width: 22px;             /* bigger icon container */
            display: inline-block;
            text-align: center;
        }

        #dc-info-tab .dc-icon-small i {
            font-size: 18px;         /* slightly larger icons */
        }

        /* Data Center Info Tab - Expanded / Large */
        #dc-info-tab.large {
            width: 420px;
            height: 520px;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            overflow-y: auto;
            font-size: 1rem;
            padding: 24px;
            flex-direction: column;
            gap: 14px;
            cursor: default;
        }

        /* Close Button */
        #dc-info-tab #close-dc-tab {
            align-self: flex-end;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.4rem;
            cursor: pointer;
        }
        /* More Insights panel for Water */
        #more-insights {
            position:absolute;
            top:50%;
            left:10px;
            transform:translateY(-50%);
            background:rgba(30,41,59,0.95);
            color:#fff;
            padding:10px 12px;
            border-radius:10px;
            box-shadow:0 8px 20px rgba(0,0,0,0.5);
            z-index:510;
            display:none;
            flex-direction:column;
            gap:8px;
            font-size:0.85rem;
        }
        #more-insights .insight-item { cursor:pointer; display:flex; align-items:center; gap:6px; }

        /* Central Graph Panel (Water vs Carbon) */
        #insight-graph-panel {
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%, -50%);
            width:80vw;        /* increased width relative to viewport */
            height:70vh;       /* increased height relative to viewport */
            max-width:1200px; /* optional max limits */
            max-height:900px;
            background:rgba(15,42,66,0.95);
            border-radius:12px;
            box-shadow:0 8px 20px rgba(0,0,0,0.5);
            color:#fff;
            display:none;
            flex-direction:column;
            z-index:600;
            padding:20px;
            overflow:auto;      /* allow scrolling if needed */
        }

        /* Graph placeholder fills the panel */
        #graph-placeholder {
            flex:1;
            display:flex;
            align-items:center;
            justify-content:center;
            border:2px dashed #6EC1E4;
            color:#6EC1E4;
            width:100%;
            height:100%;
        }

        /* Inner canvas fills placeholder */
        #graph-placeholder canvas {
            width:100% !important;
            height:100% !important;
        }

        /* Carbon Projection Modal */
        #carbon-projection-modal {
            display: none;             /* Hidden initially */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background: rgba(15,42,66,0.95);
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            color: #fff;
            z-index: 600;
            padding: 20px;
            flex-direction: column;
        }

        /* Make the chart canvas fill the modal */
        #carbonProjectionChart {
            flex: 1;              /* Fill the parent container */
            width: 100% !important;
            height: 100% !important;
        }

        /* Footer & Ribbon */
        #footer-timestamp { position:absolute; bottom:10px; right:15px; background:rgba(30,41,59,0.85); padding:6px 12px;
            border-radius:10px; color:#f0f0f0; font-size:0.8rem; box-shadow:0 4px 10px rgba(0,0,0,0.3); z-index:500; }

        /* Title Ribbon */
        #title-ribbon {
            height: 60px; /* taller */
            line-height: 60px; /* vertically center text */
            font-size: 1.8rem; /* bigger text */
            font-weight: 700;
            background: linear-gradient(to right,#0f2b42,#1a3c54);
            text-align: center;
            color: #e0e0e0;
        }

        /* Navigation Ribbon */
        #nav-ribbon {
            height: 60px; /* taller */
            line-height: 60px; /* vertically center items */
            background: #1a3c54;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }

        .nav-item {
            font-size: 1.1rem; /* slightly bigger nav options */
            padding: 0 18px;
            line-height: 60px; /* match ribbon height */
        }
        .nav-item:hover { background:rgba(255,255,255,0.1); border-radius:6px; }
        .nav-item.active { border-bottom:3px solid #6EC1E4; }

        .legend { position:absolute; bottom:10px; left:10px; background:rgba(30,41,59,0.9); color:#fff;
            padding:10px; border-radius:8px; font-size:0.8rem; box-shadow:0 4px 10px rgba(0,0,0,0.3); z-index:500; }
        .legend div { display:flex; align-items:center; margin-bottom:4px; }
        .legend span { display:inline-block; width:16px; height:16px; margin-right:6px; border-radius:4px; }

        #hover-aqi { position:absolute; pointer-events:none; padding:6px 10px; background:rgba(30,41,59,0.9);
            color:#fff; border-radius:8px; font-size:0.85rem; z-index:600; display:none; }

        .dc-icon i { pointer-events:none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <div id="header-wrapper">
        <div id="title-ribbon">Environmental Impact of Data Centers</div>
        <div id="nav-ribbon">
            <div class="flex gap-3">
                <div class="nav-item active" data-layer="air">Air Quality</div>
                <div class="nav-item" data-layer="water">Water</div>
                <div class="nav-item" data-layer="power">Power</div>
                <div class="nav-item" data-layer="co2">CO2</div>
                <div class="nav-item" data-layer="summary">Data Centers Summary</div>
            </div>
        </div>
    </div>

    <div id="dc-info-tab">
        <button id="close-dc-tab">‚úñ</button>

  <div>
    <span class="dc-icon-small"><i class="fas fa-database" style="color:whitesmoke;"></i></span>
    <strong id="dc-name">DC Name</strong>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-layer-group" style="color:whitesmoke;"></i></span>
    <strong>Size In Acres:</strong> <span id="dc-size">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-bolt" style="color:#e1c03e;"></i></span>
    <strong>Power Source:</strong> <span id="dc-power">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-snowflake" style="color:#6287c1;"></i></span>
    <strong>Cooling Source:</strong> <span id="dc-cooling">N/A</span>
  </div>

  <!-- Extra fields in same style -->
  <div>
    <span class="dc-icon-small"><i class="fas fa-building" style="color:#c59632;"></i></span>
    <strong>Operator:</strong> <span id="dc-operator">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-city" style="color:#8d4794;"></i></span>
    <strong>City:</strong> <span id="dc-city">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-map-marker-alt" style="color:#4777c4;"></i></span>
    <strong>State:</strong> <span id="dc-state">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-dollar-sign" style="color:#329235;"></i></span>
    <strong>Project Cost:</strong> <span id="dc-cost">N/A</span>
  </div>
  <div>
    <span class="dc-icon-small"><i class="fas fa-info-circle" style="color:#e76464;"></i></span>
    <strong>Status:</strong> <span id="dc-status">N/A</span>
  </div>
</div>

    <div id="directions-btn"
        style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #1e40af;
            color: white;
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            z-index: 9000; /* <-- INCREASED Z-INDEX */
            font-size: 0.85rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        ">
        Directions on Navigating the Page
    </div>

    <div id="map-info-box"></div>

    <style>
        #map-info-box {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 340px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(30, 41, 59, 0.95);
            color: #f0f0f0;
            padding: 18px 20px;
            border-radius: 16px;
            box-shadow: 0 12px 28px rgba(0,0,0,0.6);
            font-size: 0.92rem;
            line-height: 1.5rem;
            z-index: 550;
            display: none; /* initially hidden */
        }

        #map-info-box strong {
            color: #6EC1E4;
        }

        #map-info-box div {
            margin-bottom: 10px;
        }

        #map-info-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 32px rgba(0,0,0,0.65);
        }
    </style>

    <script>
        const btn = document.getElementById('directions-btn');
        const box = document.getElementById('map-info-box');
        const closeBtn = document.getElementById('close-info-box');

        const layerInfo = {
            Air: `<div><strong>Map Overview:</strong> The map displays current AQI across locations and data center sites.</div>
                        <div><strong>Air Quality (AQI) Layer:</strong> Hover over the map to see the AQI at specific locations. AQI can be viewed for Ozone, PM2.5, PM10, or ‚ÄúOzone and PM‚Äù (the highest NowCast AQI among the three).</div>
                        <div><strong>Data Center Layer:</strong> Click on a data center to view details such as name, size rank, power source, cooling source, operator, city, state, project cost, and status.</div>
                        <div><strong>Interactions:</strong> Click a monitor or data center to explore more detailed info. Use the layer options to switch AQI view by pollutant.</div>`,
           Water: `<div><strong>Water Footprint Layer Overview:</strong> The Water Footprint layer visualizes the water usage intensity (m¬≥/MWh) associated with power generation across different locations.</div>
  <div><strong>Map Markers:</strong> Color and size of each marker indicate the water footprint ‚Äî darker colors and larger circles represent a higher footprint. Hover over any circle to see the exact water footprint value (m¬≥/MWh).</div>
  <div><strong>More Insights Panel:</strong> The left-hand side includes deeper analysis through interactive charts:</div>
  <div style="margin-left:16px;">
      1. <strong>Fuel Type Analysis</strong> ‚Äì Shows how water footprint varies by primary fuel type.<br>
      2. <strong>Subbasin Analysis</strong> ‚Äì Breaks down footprint across subbasins to reveal regional variations.<br>
      3. <strong>Water Projection Analysis</strong> ‚Äì Displays best- and worst-case scenarios for future water usage.
  </div>
  <div><strong>Interactive Graphs:</strong> All charts are interactive‚Äîhover over any point to see tooltips. Charts open in the center of the screen when selected from the insights list.</div>
`,
            Power: `<div><strong>Power Consumption Layer Overview:</strong> The Power Layer visualizes the total electricity consumption (MWh) by power facilities across different locations.</div>
  <div><strong>Map Markers:</strong> Color and size of markers indicate power consumption ‚Äî larger, darker markers represent higher MWh values. Hover over any circle to see the power consumption.</div>
  <div><strong>Filter Controls:</strong> Use the State, Fuel, and PCA filters on the right to narrow down the view, and the aggregation filter to switch between individual facilities or state averages.</div>
  <div><strong>Data Center Interaction:</strong> Click on a data center to view operational and environmental details.</div>`,
            CO2: `<div><strong>CO‚ÇÇ Emissions Layer Overview:</strong> The CO‚ÇÇ Layer visualizes the carbon footprint (kg/MWh) of power facilities.</div>
  <div><strong>Map Markers:</strong> Marker size and color scale with the CO‚ÇÇ footprint. Hover to see the specific CO‚ÇÇ value (kg/MWh).</div>
  <div><strong>More Insights Panel:</strong> The left-hand side includes charts for deeper analysis:</div>
  <div style="margin-left:16px;">
      1. <strong>Fuel Type Analysis</strong> ‚Äì Shows how CO‚ÇÇ footprint varies by primary fuel type.<br>
      2. <strong>Carbon Projection Analysis</strong> ‚Äì Displays best- and worst-case scenarios for future CO‚ÇÇ emissions.
  </div>
  <div><strong>Filter Controls:</strong> Use the State, Fuel, and PCA filters to narrow down the view, and the aggregation filter to switch between individual facilities or state averages.</div>`
        };

        // **Step 1: Define the function globally**
// Place this function *before* the updateInfoBox function or at the start of your main script block.

function ensureCloseButton() {
    let closeBtnEl = document.getElementById('close-info-box');
    // Ensure the box element is retrieved if needed, though it should be globally defined
    const infoBox = document.getElementById('map-info-box');

    if (!closeBtnEl && infoBox) {
        closeBtnEl = document.createElement('button');
        closeBtnEl.id = 'close-info-box';
        closeBtnEl.innerText = '‚úñ';
        closeBtnEl.style.position = 'absolute';
        closeBtnEl.style.top = '12px';
        closeBtnEl.style.right = '16px';
        closeBtnEl.style.background = 'transparent';
        closeBtnEl.style.border = 'none';
        closeBtnEl.style.color = '#fff';
        closeBtnEl.style.fontSize = '1.3rem';
        closeBtnEl.style.cursor = 'pointer';
        closeBtnEl.style.zIndex = '10';
        closeBtnEl.addEventListener('click', () => {
            // Note: 'box' and 'btn' must be defined as global consts (which they are in your setup)
            box.style.display = 'none';
            btn.innerText = 'Directions on Navigating the Page';
        });
        infoBox.appendChild(closeBtnEl);
    }
}


// **Step 2: Replace your old updateInfoBox function with this simplified version**

function updateInfoBox(layer) {
    box.innerHTML = layerInfo[layer] || '<div>No info available for this layer.</div>';
    ensureCloseButton(); // Simply call the globally defined function
}


// **Step 3: Keep the rest of your original code (it is now correct)**

// Default to AirQuality initially
updateInfoBox('Air');

btn.addEventListener('click', () => {
    // Determine the capitalized layer name to look up in layerInfo
    let layerKey = currentLayer.charAt(0).toUpperCase() + currentLayer.slice(1);

    // üí° NEW: Specific check for CO2 (which is ALL CAPS in layerInfo)
    if (layerKey === 'Co2') {
        layerKey = 'CO2';
    }

    if(box.style.display === 'none'){
        // Use the corrected key
        updateInfoBox(layerKey);

        ensureCloseButton();
        box.style.display = 'block';
        btn.innerText = 'Hide Directions';
    } else {
        box.style.display = 'none';
        btn.innerText = 'Directions on Navigating the Page';
    }
});
    </script>


    <div id="monitor-panel">
        <strong>Monitor Layer</strong>
        <label class="cursor-pointer label">
            <input type="radio" name="monitor-layer" checked class="radio radio-sm mr-2"> Ozone and PM
        </label>
        <label class="cursor-pointer label">
            <input type="radio" name="monitor-layer" class="radio radio-sm mr-2"> Ozone only
        </label>
        <label class="cursor-pointer label">
            <input type="radio" name="monitor-layer" class="radio radio-sm mr-2"> PM2.5 only
        </label>
    </div>

    <div id="more-insights">
        <strong>More Insights (click to view)</strong>

  <!-- Existing Fuel Type -->
  <div class="insight-item" data-type="fuel">
    <i class="fas fa-gas-pump" style="color:rgb(227, 209, 70);"></i> Fuel Type
  </div>

  <!-- Dynamically added Water Projections (via JS) -->
  <div id="water-projection-tab" class="insight-item">
    <i class="fas fa-water" style="color:#426bad;"></i> Water Projections
  </div>
</div>

    <div id="carbon-projection-modal" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
        width:600px; height:400px; background:rgba(15,42,66,0.95); border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.5);
        color:#fff; z-index:600; padding:20px; display:flex; flex-direction:column;">
        <button id="close-carbon-projection" style="align-self:flex-end; background:transparent; border:none; color:#fff; font-size:1.2rem; cursor:pointer;">‚úñ</button>
        <div style="font-weight:600; font-size:1.2rem; margin-bottom:10px;">Carbon Projections</div>
        <canvas id="carbonProjectionChart"></canvas>
    </div>


    <div id="insight-graph-panel">
        <button id="close-graph-panel">‚úñ</button>
        <div id="graph-title" style="font-weight:600; font-size:1.2rem; margin-bottom:10px;">Fuel Type Analysis</div>
        <div id="graph-placeholder">Graph Placeholder</div>
    </div>
    <style>
        /* Full overlay covering the map */
        #summary-overlay {
            position: absolute;
            top: 120px; /* adjust to map header */
            bottom: 0;
            right: 0;
            left: 0;
            z-index: 550;
            background: #111827;
            display: none; /* initially hidden */
            padding: 10px;
            box-sizing: border-box;
        }

        /* Update this section in your main <style> block or the injected <style> block */

        /* 2x2 grid for charts */
        #summary-grid {
            display: grid;
            width: 100%;
            height: 100%;
            grid-template-columns: 1fr 1fr; /* Keep 1fr 1fr for equal columns */
            grid-template-rows: 1fr 1fr;    /* Keep 1fr 1fr for equal rows */
            gap: 12px;
        }

        /* Each grid box - IMPORTANT UPDATE */
        .grid-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;

            /* Ensure content fills the space and handles overflow */
            display: flex; /* Ensures canvas fills the box */
            justify-content: center;
            align-items: center;
            padding: 10px;
            overflow: hidden; /* Prevent labels/bars from forcing the layout wide */
            box-sizing: border-box; /* Crucial for padding to work with width/height */
        }

        /* Make the canvas fill the grid box */
        .grid-box canvas {
            width: 100% !important;
            height: 100% !important;
        }
    </style>

    <div id="summary-overlay">
        <div id="summary-grid">
            <div class="grid-box" style="position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <div id="total-dc-count" style="position: absolute; top: 10px; right: 16px; color:#fff; font-size:1.05rem; font-weight: 500; z-index:2; background:rgba(30,41,59,0.0); border:2px solid #fff; border-radius:8px; padding:6px 14px; box-shadow:0 2px 8px rgba(0,0,0,0.18);">
                </div>
                <canvas id="plot-status"></canvas>
            </div>
            <div class="grid-box"><canvas id="plot-states"></canvas></div>
            <div class="grid-box"><canvas id="plot-operators"></canvas></div>
            <div class="grid-box"><canvas id="plot-size"></canvas></div>
        </div>
    </div>
    <div id="map"></div>

    <div id="water-projection-modal" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
        width:600px; height:400px; background:rgba(15,42,66,0.95); border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.5);
        color:#fff; z-index:600; padding:20px; flex-direction:column;">
        <button id="close-water-projection" style="align-self:flex-end; background:transparent; border:none; color:#fff; font-size:1.2rem; cursor:pointer;">‚úñ</button>
        <div style="font-weight:600; font-size:1.2rem; margin-bottom:10px;">Water Projections</div>
        <canvas id="waterProjectionChart" width="560" height="300"></canvas>
    </div>

    <select id="aggregation-filter" style="
    position: absolute;
    top: 250px; /* Adjusted position to place it below the subbasin filter (210px + some space) */
    right: 20px;
    z-index: 550;
    background: rgba(30,41,59,0.95);
    color: #fff;
    border-radius: 6px;
    padding: 6px 10px;
    border: 1px solid #ccc;
    font-size: 0.9rem;
    width: 150px;
    max-width: 150px;
    overflow-y: auto;
    text-overflow: ellipsis;
    white-space: nowrap;
" size="1">
    <option value="point" selected>Plot by Facility</option>
    <option value="state">Plot by State Average</option>
</select>

    <select id="state-filter" style="
        position: absolute;
        top: 130px;
        right: 20px;
        z-index: 550;
        background: rgba(30,41,59,0.95);
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        border: 1px solid #ccc;
        font-size: 0.9rem;
        width: 150px;
        max-width: 150px;
        overflow-y: auto;
        text-overflow: ellipsis;
        white-space: nowrap;
    " size="5">
        <option value="all">All States</option>
    </select>

    <select id="fuel-filter" style="
        position: absolute;
        top: 170px;
        right: 20px;
        z-index: 550;
        background: rgba(30,41,59,0.95);
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        border: 1px solid #ccc;
        font-size: 0.9rem;
        width: 150px;
        max-width: 150px;
        overflow-y: auto;
        text-overflow: ellipsis;
        white-space: nowrap;
    " size="5">
        <option value="all">All Fuels</option>
    </select>

    <select id="subbasin-filter" style="
        position: absolute;
        top: 210px;
        right: 20px;
        z-index: 550;
        background: rgba(30,41,59,0.95);
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        border: 1px solid #ccc;
        font-size: 0.9rem;
        width: 150px;
        max-width: 150px;
        overflow-y: auto;
        text-overflow: ellipsis;
        white-space: nowrap;
    " size="5">
        <option value="all">PCA</option>
    </select>
    <style>
        /* Hide filters by default */
        #state-filter, #fuel-filter, #subbasin-filter {
            display: none; /* hide by default */
        }
    </style>


    <div id="footer-timestamp">Loading data...</div>
    <div id="hover-aqi"></div>
    <div class="legend" id="legend"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <script>
        const startZoom = 5;
        const map = L.map('map', {
            center: [39.5, -98.35],  // center of continental US
            zoom: startZoom,          // starting zoom
            minZoom: startZoom        // restrict zoom out to starting zoom
            
        });

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
            subdomains: 'abcd',
            maxZoom: 19              // tile layer maxZoom
        }).addTo(map);

        let currentPollutant = "all";
        let monitorData = [];
        let waterData = [];
        let dcMarkers = [];
        let heatLayer = null;
        let currentLayer = "air";
        let initialLoad = true; // flag for first load
        let carbonMarkers = []; // keep track of CO2 circle markers
        let waterHeatLayer = null; // add at the top with other globals
        let waterMarkers = []; // global
        let waterPulseInterval = null; // store interval so we can clear it
        let aqiMarkers = []; // track AQI circle markers
        let powerData = [];
        let powerMarkers = [];
        let powerHeatLayer = null;
        let powerPulseInterval = null;

// --- Legends ---
function setLegend(layer) {
    const legend = document.getElementById('legend');
    if (!legend) return;

    legend.innerHTML = ''; // clear previous content

    if(layer === 'air') {
        // Fixed 4-category legend
        legend.innerHTML = `
            <div><span style="background:green"></span>0 ‚Äì 5</div>
            <div><span style="background:yellow"></span>6 ‚Äì 15</div>
            <div><span style="background:orange"></span>16 ‚Äì 35</div>
            <div><span style="background:red"></span>36+</div>
            <div><span style="background:whitesmoke"></span>Data Center</div>
        `;
    } else if(layer === 'water') {
        legend.innerHTML = `
            <div><span style="background:#3B82F6;opacity:0.5;"></span>Low footprint</div>
            <div><span style="background:#0EA5E9;opacity:0.5;"></span>Moderate footprint</div>
            <div><span style="background:#06B6D4;opacity:0.5;"></span>High footprint</div>
            <div><span style="background:#22C55E;opacity:0.5;"></span>Very High footprint</div>
            <div><span style="background:#F87171;opacity:0.5;"></span>Extreme footprint</div>
            <div><span style="background:white;opacity:0.5;"></span>Data Center</div>
        `;
    } else if(layer === 'co2') {
        legend.innerHTML = `
            <div><span style="background:#FFD580"></span>Low CO‚ÇÇ</div>
            <div><span style="background:#FFA500"></span>Moderate CO‚ÇÇ</div>
            <div><span style="background:#FF6A00"></span>High CO‚ÇÇ</div>
            <div><span style="background:#FF0000"></span>Very High CO‚ÇÇ</div>
            <div><span style="background:#8B0000"></span>Extreme CO‚ÇÇ</div>
            <div><span style="background:whitesmoke"></span>Data Center</div>
        `;
    } else if(layer === 'power') {
        legend.innerHTML = `
            <div><span style="background:#FFF3BF"></span>Low Power</div>
            <div><span style="background:#FFD580"></span>Moderate Power</div>
            <div><span style="background:#FFA500"></span>High Power</div>
            <div><span style="background:#FF6A00"></span>Very High Power</div>
            <div><span style="background:#FF0000"></span>Extreme Power</div>
            <div><span style="background:whitesmoke"></span>Data Center</div>
        `;
    }
}

/// --- Event listener for aggregation filter (UPDATED to include AQI) ---
const aggregationSelect = document.getElementById('aggregation-filter');

if (aggregationSelect) {
    aggregationSelect.addEventListener('change', async () => {
        const { state, fuel, subbasin } = getFilterValues();
        const aggregationLevel = aggregationSelect.value; // 'point' or 'state'

        // Check the current layer before loading the data
        if (currentLayer === 'water') {
            await loadWaterHeatmap(state, fuel, subbasin, aggregationLevel);
        } else if (currentLayer === 'power') {
            await loadPowerHeatmap(state, fuel, subbasin, aggregationLevel);
        } else if (currentLayer === 'co2') {
            await loadCarbonHeatmap(state, fuel, subbasin, aggregationLevel);
        } else if (currentLayer === 'air') { // üëà NEW AQI LOGIC ADDED
            // AQI layer relies only on selectedState and aggregationLevel.
            await loadAQIHeatmap(state, aggregationLevel);
        }
    });
}

        // --- Load Data Centers ---
        async function loadDataCenters() {
            try {
                const res = await fetch('https://data-center-map-nu1d.onrender.com/api/monitors');
                const data = await res.json();
                if (!data.data_centers || data.data_centers.length === 0) return;

                // Remove old markers
                dcMarkers.forEach(m => map.removeLayer(m));
                dcMarkers = [];

                data.data_centers.forEach(dc => {
                    if (!dc.lat || !dc.lon) return;

      const marker = L.marker([Number(dc.lat), Number(dc.lon)], {
        icon: L.divIcon({
          className: 'dc-icon',
          html: `<i class="fas fa-database" style="color:whitesmoke;font-size:12px;"></i>`
        })
      }).addTo(map);

                    marker.on('click', () => {
                        const tab = document.getElementById('dc-info-tab');
                        // Ensure the tab is small when opened by removing the 'large' class
                        tab.classList.remove('large');
                        tab.style.display = 'flex';

                        // Populate the data center info tab with data
                        document.getElementById('dc-name').innerText = dc.Name || 'N/A';
                        document.getElementById('dc-operator').innerText = dc.Operator || 'N/A';
                        document.getElementById('dc-power').innerText = dc.PowerSource || 'N/A';
                        document.getElementById('dc-cooling').innerText = dc.CoolingSource || 'N/A';
                        document.getElementById('dc-city').innerText = dc.City || 'N/A';
                        document.getElementById('dc-state').innerText = dc.State || 'N/A';
                        document.getElementById('dc-size').innerText = dc.PropertySizeAcres || 'N/A';
                        document.getElementById('dc-cost').innerText = dc.ProjectCost || 'N/A';
                        document.getElementById('dc-status').innerText = dc.Status || 'N/A';
                    });

                    dcMarkers.push(marker);
                });

            } catch (error) {
                console.error('Error loading data centers:', error);
            }
        }

// Global variable to store the choropleth layer for AQI
let aqiChoroplethLayer = null;

// AQI Color Helper (4 fixed categories)
function getChoroplethAQIColor(aqiValue) {
    if (aqiValue <= 5) return 'green';       // 0‚Äì5
    if (aqiValue <= 15) return 'yellow';     // 6‚Äì15
    if (aqiValue <= 35) return 'orange';     // 16‚Äì35
    return 'red';                            // 36+
}

// Dedicated function to clear AQI layers (must be called by clearHeatLayer)
function clearAQILayer() {
    // Clear markers
    if (aqiMarkers && aqiMarkers.length > 0) {
        aqiMarkers.forEach(m => map.removeLayer(m));
        aqiMarkers = [];
    }
    // Clear choropleth
    if (aqiChoroplethLayer) {
        map.removeLayer(aqiChoroplethLayer);
        aqiChoroplethLayer = null;
    }
    // Clear old heat layer (if used)
    if (heatLayer) { // Re-using existing global heatLayer variable for clarity
        map.removeLayer(heatLayer);
        heatLayer = null;
    }
}

// Choropleth Renderer for AQI
async function renderStateChoroplethAQI(aqiData) {
    if (aqiChoroplethLayer) {
        map.removeLayer(aqiChoroplethLayer);
        aqiChoroplethLayer = null;
    }

    try {
        const res = await fetch(US_STATES_GEOJSON_URL);
        if (!res.ok) throw new Error(`Failed to load GeoJSON: ${res.status}`);
        const geojsonData = await res.json();

        function getDataKey(geojsonName) {
            return stateAbbreviations[geojsonName];
        }

        function styleFeature(feature) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgAqi = aqiData[dataKey] || 0;

            return {
                fillColor: getChoroplethAQIColor(avgAqi),
                weight: 1.5,
                opacity: 1,
                color: 'white',
                fillOpacity: avgAqi > 0 ? 0.75 : 0.4
            };
        }

        function onEachFeature(feature, layer) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgAqi = aqiData[dataKey];

            let tooltipText = `<strong>${geojsonName} (${dataKey || 'N/A'})</strong><br>`;
            tooltipText += avgAqi !== undefined ?
                           `Avg. AQI: ${avgAqi.toFixed(0)}` :
                           `No monitor data available.`;

            layer.bindTooltip(tooltipText, { sticky: true, direction: 'center' });

            layer.on({
                mouseover: (e) => { e.target.setStyle({ weight: 3, color: '#666', fillOpacity: 0.9 }); },
                mouseout: (e) => { aqiChoroplethLayer.resetStyle(e.target); },
            });
        }

        aqiChoroplethLayer = L.geoJson(geojsonData, {
            style: styleFeature,
            onEachFeature: onEachFeature
        }).addTo(map);

    } catch (error) {
        console.error("Error rendering AQI choropleth map:", error);
    }
}

// --- Load AQI Markers or Choropleth ---
async function loadAQIHeatmap(selectedState = "all", aggregationLevel = "point") {
    try {
        // Assume currentPollutant is available globally
        const res = await fetch(`https://data-center-map-nu1d.onrender.com/api/monitors?pollutant=${currentPollutant}`);
        const data = await res.json();
        let monitorData = data.monitors || [];
        if (!monitorData.length) return;

        // ------------------------------------------------------------
        // üåü 1. Apply filters BEFORE aggregation
        // ------------------------------------------------------------
        let filteredData = monitorData.slice();
        if (selectedState !== "all") filteredData = filteredData.filter(m => m.state === selectedState);

        // ------------------------------------------------------------
        // üåü 2. STATE-LEVEL AGGREGATION (Average AQI)
        // ------------------------------------------------------------
        const stateTotals = {};
        filteredData.forEach(m => {
            const state = m.state;
            const aqi = parseFloat(m.aqi) || 0;
            if (state) {
                if (!stateTotals[state]) {
                    stateTotals[state] = { totalAqi: 0, count: 0 };
                }
                stateTotals[state].totalAqi += aqi;
                stateTotals[state].count += 1;
            }
        });

        // Calculate average AQI for choropleth plotting
        let stateDataForChoropleth = {};
        let allAvgs = [];

        for (const state in stateTotals) {
            const avg = stateTotals[state].totalAqi / stateTotals[state].count;
            stateDataForChoropleth[state] = avg;
            allAvgs.push(avg);
        }

        // Max AQI across the filtered/aggregated data (for optional normalization)
        const maxAqiAgg = Math.max(...allAvgs, 0);

        // --- Clear ALL layers for this theme before plotting ---
        clearAQILayer();


        // ------------------------------------------------------------
        // üåü 3. PLOTTING MODE (state choropleth vs point)
        // ------------------------------------------------------------
        if (aggregationLevel === "state") {
            // **A. CHOROPLETH PLOTTING**
            if (typeof renderStateChoroplethAQI === "function") {
                // Pass the aggregated average data and its max value (maxAqi is optional here,
                // as AQI colors are based on fixed EPA thresholds)
                renderStateChoroplethAQI(stateDataForChoropleth, maxAqiAgg);
            } else {
                console.error("renderStateChoroplethAQI is not defined! Cannot draw state polygons.");
            }
        } else {
            // --- POINT PLOTTING (Markers with gradient color based on max AQI) ---
// --- POINT PLOTTING (Markers with fixed 4-category colors) ---
let dataToPlot = filteredData;
if (!dataToPlot.length) return;

// Define 4 fixed color categories
const colors = ["#00ff00", "#ffff00", "#ffa500", "#ff0000"]; // green ‚Üí yellow ‚Üí orange ‚Üí red

// Determine category based on AQI value
function getColorByCategory(aqi) {
    if (aqi <= 5) return colors[0];       // 0‚Äì5
    if (aqi <= 15) return colors[1];      // 6‚Äì15
    if (aqi <= 35) return colors[2];      // 16‚Äì35
    return colors[3];                      // 36+
}

// Plot each monitor
dataToPlot.forEach(m => {
    const aqi = parseFloat(m.aqi) || 0;
    const color = getColorByCategory(aqi);

    const marker = L.circleMarker([m.lat, m.lon], {
        radius: 5,           // fixed size
        color: color,
        fillColor: color,
        fillOpacity: 0.85,
        weight: 1
    })
    .addTo(map)
    .bindTooltip(`AQI: ${aqi}`, {
        direction: 'top',
        className: 'aqi-tooltip'
    });

    aqiMarkers.push(marker);
});



        }


        // 4. --- Dropdown Population Logic (Updated based on all available monitors) ---
        const availableStates = [...new Set(monitorData.map(m => m.state).filter(Boolean))].sort();

        const stateSelect = document.getElementById('state-filter');
        if (stateSelect) {
            // ... (Dropdown population logic for stateSelect restored here) ...
            stateSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'All States';
            allOption.selected = selectedState === 'all';
            stateSelect.appendChild(allOption);

            availableStates.forEach(s => {
                const option = document.createElement('option');
                option.value = s;
                option.text = s;
                if (s === selectedState) option.selected = true;
                stateSelect.appendChild(option);
            });
            stateSelect.size = 1;
        }

        // Note: Filters for Fuel and PCA are not populated for AQI as they are not relevant to monitors.

        // Update timestamp + legend
        document.getElementById('footer-timestamp').innerText =
            `Updated: ${new Date(data.timestamp).toLocaleString()}`;
        setLegend('air');

    } catch (err) {
        console.error('Error loading AQI:', err);
    }
}

    // Global variable to store the state data for the choropleth
let stateDataForChoropleth = {};
// Global variable to store the choropleth layer
let choroplethLayer = null;

function getChoroplethColor(footprintValue, maxFootprint) {
    if (maxFootprint === 0) return '#E0E7FF'; // Default if no data

    // Calculate normalized intensity (0 to 1)
    const intensity = footprintValue / maxFootprint;

    // Use normalized intensity to set color thresholds dynamically
    // Colors are matched to your existing Water layer colors (approx. 0.2 increments)
    if (intensity > 0.8) return '#F87171'; // Extreme (Red)
    if (intensity > 0.6) return '#22C55E'; // Very High (Green) - Note: This mapping is unusual for "Very High," but matches your original code's fixed value colors.
    if (intensity > 0.4) return '#06B6D4'; // High (Dark Cyan)
    if (intensity > 0.2) return '#0EA5E9'; // Moderate (Light Blue)
    if (intensity > 0.05) return '#3B82F6'; // Low (Blue)
    return '#E0E7FF'; // Very Low/Default (Off-white)
}

// NOTE: You must also ensure clearWaterLayer removes the choroplethLayer:
// function clearWaterLayer() { /* ... existing clear logic ... */ if (choroplethLayer) { map.removeLayer(choroplethLayer); choroplethLayer = null; } }
// Add this new function to your global script block
// Replace it with this public URL (or your internal API/file path):
const US_STATES_GEOJSON_URL = 'https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json';
// --- Global Mapping Table (Add this to your global script area) ---
const stateAbbreviations = {
    "Alabama": "AL", "Alaska": "AK", "Arizona": "AZ", "Arkansas": "AR", "California": "CA",
    "Colorado": "CO", "Connecticut": "CT", "Delaware": "DE", "Florida": "FL", "Georgia": "GA",
    "Hawaii": "HI", "Idaho": "ID", "Illinois": "IL", "Indiana": "IN", "Iowa": "IA",
    "Kansas": "KS", "Kentucky": "KY", "Louisiana": "LA", "Maine": "ME", "Maryland": "MD",
    "Massachusetts": "MA", "Michigan": "MI", "Minnesota": "MN", "Mississippi": "MS",
    "Missouri": "MO", "Montana": "MT", "Nebraska": "NE", "Nevada": "NV", "New Hampshire": "NH",
    "New Jersey": "NJ", "New Mexico": "NM", "New York": "NY", "North Carolina": "NC",
    "North Dakota": "ND", "Ohio": "OH", "Oklahoma": "OK", "Oregon": "OR", "Pennsylvania": "PA",
    "Rhode Island": "RH", "South Carolina": "SC", "South Dakota": "SD", "Tennessee": "TN",
    "Texas": "TX", "Utah": "UT", "Vermont": "VT", "Virginia": "VA", "Washington": "WA",
    "West Virginia": "WV", "Wisconsin": "WI", "Wyoming": "WY"
    // Note: If GeoJSON uses 'Rhode Island', I've corrected it to 'RH' here. If your data uses RI, change RH to RI.
};

async function renderStateChoropleth(footprintData, maxFootprint) {
    if (choroplethLayer) {
        map.removeLayer(choroplethLayer);
        choroplethLayer = null;
    }

    try {
        const res = await fetch(US_STATES_GEOJSON_URL);
        if (!res.ok) throw new Error(`Failed to load GeoJSON: ${res.status}`);
        const geojsonData = await res.json();


        function getDataKey(geojsonName) {
            // Assumes stateAbbreviations is defined globally (e.g., {"Maine": "ME", "Washington": "WA"})
            return stateAbbreviations[geojsonName];
        }

        function styleFeature(feature) {
            const geojsonName = feature.properties.name; // <--- Corrected to 'name'
            const dataKey = getDataKey(geojsonName); // Get the 2-letter code (e.g., "WA")
            const avgFootprint = footprintData[dataKey] || 0; // Look up using the 2-letter code

            return {

                fillColor: getChoroplethColor(avgFootprint, maxFootprint),
                weight: 1.5,
                opacity: 1,
                color: 'white',
                fillOpacity: avgFootprint > 0 ? 0.75 : 0.4
            };
        }

        // Function to define behavior on hover/click
        function onEachFeature(feature, layer) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName); // Get the 2-letter code (e.g., "WA")
            const avgFootprint = footprintData[dataKey]; // Lookup using the 2-letter code

            let tooltipText = `<strong>${geojsonName} (${dataKey || 'N/A'})</strong><br>`;
            tooltipText += avgFootprint ?
                           `Avg. Water Footprint: ${avgFootprint.toFixed(2)} m¬≥/MWh` :
                           `No facility data available.`;

            layer.bindTooltip(tooltipText, { sticky: true, direction: 'center' });

            layer.on({
                mouseover: (e) => { e.target.setStyle({ weight: 3, color: '#666', fillOpacity: 0.9 }); },
                mouseout: (e) => { choroplethLayer.resetStyle(e.target); },
            });
        }

        // Create and add the GeoJSON layer to the map
        choroplethLayer = L.geoJson(geojsonData, {
            style: styleFeature,
            onEachFeature: onEachFeature
        }).addTo(map);

    } catch (error) {
        console.error("Error rendering choropleth map:", error);
    }
}

async function loadWaterHeatmap(selectedState = "all", selectedFuel = "all", selectedSubbasin = "all", aggregationLevel = "point") {
    try {
        const res = await fetch('https://data-center-map-nu1d.onrender.com/api/water');
        const data = await res.json();
        let waterData = data.points || [];
        if (!waterData.length) return;

        // 1. --- Apply filters for initial data subset (before aggregation) ---
        let filteredData = waterData.slice();
        if (selectedState !== "all") filteredData = filteredData.filter(p => p.state === selectedState);
        if (selectedFuel !== "all") filteredData = filteredData.filter(p => p.primary_fuel === selectedFuel);
        if (selectedSubbasin !== "all") filteredData = filteredData.filter(p => p.subbasin === selectedSubbasin);

        // 2. üåü AGGREGATION LOGIC: Prepare data for both markers AND choropleth üåü
        const stateFootprints = {};
        filteredData.forEach(p => {
            const state = p.state;
            const footprint = parseFloat(p.water_footprint) || 0;
            if (state) {
                if (!stateFootprints[state]) {
                    stateFootprints[state] = { totalFootprint: 0, count: 0 };
                }
                stateFootprints[state].totalFootprint += footprint;
                stateFootprints[state].count += 1;
            }
        });

        // Store the final average footprint data globally for choropleth rendering
        stateDataForChoropleth = {};
        let allFootprints = [];
        for (const state in stateFootprints) {
            const avgFootprint = stateFootprints[state].totalFootprint / stateFootprints[state].count;
            stateDataForChoropleth[state] = avgFootprint;
            allFootprints.push(avgFootprint);
        }

        const maxFootprint = Math.max(...allFootprints, 0); // Calculate max footprint from all aggregated/filtered data

        // --- Clear existing layers ---
        clearWaterLayer();
        clearPowerLayer()

        // 3. üåü PLOTTING DECISION: Choropleth or Markers üåü
        if (aggregationLevel === 'state') {
            // **A. CHOROPLETH PLOTTING**
            // The data is aggregated. Call the external function to draw state polygons.

            // NOTE: You need to define the renderStateChoropleth function separately
            // and ensure it has access to the GeoJSON boundaries.
            if (typeof renderStateChoropleth === 'function') {
                 renderStateChoropleth(stateDataForChoropleth, maxFootprint); // Pass maxFootprint for scaling/legend
            } else {
                 console.error("renderStateChoropleth function is not defined! Cannot draw state polygons.");
            }

        } else {
            // **B. POINT PLOTTING (Original Circle Logic)**
            let dataToPlot = filteredData.map(p => ({
    ...p,
    water_footprint: parseFloat(p.water_footprint) || 0,
    label: `Water footprint: ${parseFloat(p.water_footprint).toFixed(2)} m¬≥/MWh`,
    lat: parseFloat(p.lat) || 0,
    lon: parseFloat(p.lon) || 0,
}));

waterMarkers = [];
dataToPlot.forEach(p => {
    const footprint = p.water_footprint;
    
    // Color based on intensity (optional, can keep same logic)
    const intensity = Math.min(footprint / maxFootprint, 1.0);
    const color = intensity < 0.2 ? '#3B82F6' :
                  intensity < 0.4 ? '#0EA5E9' :
                  intensity < 0.6 ? '#06B6D4' :
                  intensity < 0.8 ? '#22C55E' :
                  '#F87171';

    const circle = L.circleMarker([p.lat, p.lon], {
        radius: 5,           // constant size for all markers
        color,
        fillColor: color,
        fillOpacity: 0.5,
        weight: 1,
        pane: 'markerPane'
    }).addTo(map);

    circle.bindTooltip(p.label, { direction: 'top' });
    waterMarkers.push({ circle, intensity });
});
        }


        // 4. --- Dropdown Population Logic (Unchanged) ---
        // (This section ensures the dropdowns reflect the allowed values based on current selections)
        const filteredStates = [...new Set(
            waterData
                .filter(p => (selectedFuel === "all" || p.primary_fuel === selectedFuel) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                .map(p => p.state).filter(Boolean)
        )].sort();

        const filteredFuels = [...new Set(
            waterData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                .map(p => p.primary_fuel).filter(Boolean)
        )].sort();

        const filteredSubbasins = [...new Set(
            waterData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedFuel === "all" || p.primary_fuel === selectedFuel))
                .map(p => p.subbasin).filter(Boolean)
        )].sort();

        // --- Populate STATE DROPDOWN ---
        const stateSelect = document.getElementById('state-filter');
        if (stateSelect) {
            stateSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'All States';
            allOption.selected = selectedState === 'all';
            stateSelect.appendChild(allOption);

            filteredStates.forEach(s => {
                const option = document.createElement('option');
                option.value = s;
                option.text = s;
                if (s === selectedState) option.selected = true;
                stateSelect.appendChild(option);
            });

            stateSelect.size = 1;
        }

        // --- Populate FUEL DROPDOWN ---
        const fuelSelect = document.getElementById('fuel-filter');
        if (fuelSelect) {
            fuelSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'All Fuels';
            allOption.selected = selectedFuel === 'all';
            fuelSelect.appendChild(allOption);

            filteredFuels.forEach(f => {
                const option = document.createElement('option');
                option.value = f;
                option.text = f;
                if (f === selectedFuel) option.selected = true;
                fuelSelect.appendChild(option);
            });

            fuelSelect.size = 1;
        }

        // --- Populate SUBBASIN DROPDOWN ---
        const subbasinSelect = document.getElementById('subbasin-filter');
        if (subbasinSelect) {
            subbasinSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'PCAs';
            allOption.selected = selectedSubbasin === 'all';
            subbasinSelect.appendChild(allOption);

            filteredSubbasins.forEach(sb => {
                const option = document.createElement('option');
                option.value = sb;
                option.text = sb;
                if (sb === selectedSubbasin) option.selected = true;
                subbasinSelect.appendChild(option);
            });

            subbasinSelect.size = 1;
        }

        // --- Update timestamp ---
        const footer = document.getElementById('footer-timestamp');
        if (footer && data.timestamp) {
            footer.innerText = `Updated: ${new Date(data.timestamp).toLocaleString()}`;
        }

        setLegend('water');

    } catch (err) {
        console.error('Error loading water heatmap:', err);
    }
}
function getChoroplethPowerColor(mwhValue, maxMwh) {
    if (maxMwh === 0) return '#E0E7FF'; // Default if no data

    // Normalize intensity (0 to 1)
    const intensity = mwhValue / maxMwh;

    // Use Power layer's color scheme (Yellow -> Red)
    if (intensity < 0.2) return '#FFF3BF';      // light yellow
    else if (intensity < 0.4) return '#FFD580'; // yellow-orange
    else if (intensity < 0.6) return '#FFA500'; // orange
    else if (intensity < 0.8) return '#FF6A00'; // deep orange
    else return '#FF0000';                        // red
}

// Global variable to store the choropleth layer for Power
let powerChoroplethLayer = null;

async function renderStateChoroplethPower(powerData, maxPower) {
    if (powerChoroplethLayer) {
        map.removeLayer(powerChoroplethLayer);
        powerChoroplethLayer = null;
    }

    try {
        const res = await fetch(US_STATES_GEOJSON_URL);
        if (!res.ok) throw new Error(`Failed to load GeoJSON: ${res.status}`);
        const geojsonData = await res.json();

        function getDataKey(geojsonName) {
            // Assumes stateAbbreviations is defined globally
            return stateAbbreviations[geojsonName];
        }

        function styleFeature(feature) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgMwh = powerData[dataKey] || 0;

            return {
                fillColor: getChoroplethPowerColor(avgMwh, maxPower), // üëà USING POWER COLOR
                weight: 1.5,
                opacity: 1,
                color: 'white',
                fillOpacity: avgMwh > 0 ? 0.75 : 0.4
            };
        }

        function onEachFeature(feature, layer) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgMwh = powerData[dataKey];

            let tooltipText = `<strong>${geojsonName} (${dataKey || 'N/A'})</strong><br>`;
            tooltipText += avgMwh ?
                           `Avg. Power: ${avgMwh.toFixed(2)} MWh/Facility` : // üëà USING POWER METRIC
                           `No facility data available.`;

            layer.bindTooltip(tooltipText, { sticky: true, direction: 'center' });

            layer.on({
                mouseover: (e) => { e.target.setStyle({ weight: 3, color: '#666', fillOpacity: 0.9 }); },
                mouseout: (e) => { powerChoroplethLayer.resetStyle(e.target); },
            });
        }

        // Create and add the GeoJSON layer to the map
        powerChoroplethLayer = L.geoJson(geojsonData, {
            style: styleFeature,
            onEachFeature: onEachFeature
        }).addTo(map);

    } catch (error) {
        console.error("Error rendering Power choropleth map:", error);
    }
}

function clearPowerLayer() {
    if(powerHeatLayer) {
        map.removeLayer(powerHeatLayer);
        powerHeatLayer = null;
    }
    // üåü This line is CRUCIAL for layer switching cleanup üåü
    if(powerChoroplethLayer) {
        map.removeLayer(powerChoroplethLayer);
        powerChoroplethLayer = null;
    }
    if(powerMarkers && powerMarkers.length > 0){
        powerMarkers.forEach(obj => map.removeLayer(obj.marker));
        powerMarkers = [];
    }
    if(powerPulseInterval){
        clearInterval(powerPulseInterval);
        powerPulseInterval = null;
    }
}

async function loadPowerHeatmap(
    selectedState = "all",
    selectedFuel = "all",
    selectedSubbasin = "all",
    aggregationLevel = "point"   // üåü added like water
) {
    try {
        const res = await fetch('https://data-center-map-nu1d.onrender.com/api/power');
        const data = await res.json();
        let powerData = data.points || [];
        if (!powerData.length) return;

        // ------------------------------------------------------------
        // üåü 1. Apply filters BEFORE aggregation (same as water)
        // ------------------------------------------------------------
        let filteredData = powerData.slice();
        if (selectedState !== "all") filteredData = filteredData.filter(p => p.state === selectedState);
        if (selectedFuel !== "all") filteredData = filteredData.filter(p => p.primary_fuel === selectedFuel);
        if (selectedSubbasin !== "all") filteredData = filteredData.filter(p => p.subbasin === selectedSubbasin);

        // ------------------------------------------------------------
        // üåü 2. STATE-LEVEL AGGREGATION (mirror water method)
        // ------------------------------------------------------------
        const stateTotals = {};
        filteredData.forEach(p => {
            const state = p.state;
            const mwh = parseFloat(p.total_mwh) || 0;
            if (state) {
                if (!stateTotals[state]) {
                    stateTotals[state] = { totalMwh: 0, count: 0 };
                }
                stateTotals[state].totalMwh += mwh;
                stateTotals[state].count += 1;
            }
        });

        // Global choropleth dataset (for external renderer)
        stateDataForChoropleth = {};
        let allAvgs = [];

        for (const state in stateTotals) {
            const avg = stateTotals[state].totalMwh / stateTotals[state].count;
            stateDataForChoropleth[state] = avg;
            allAvgs.push(avg);
        }

        const maxMwh = Math.max(...allAvgs, 0);


        clearPowerLayer();


        if (aggregationLevel === "state") {
            if (typeof renderStateChoroplethPower === "function") {
                renderStateChoroplethPower(stateDataForChoropleth, maxMwh);
            } else {
                console.error("renderStateChoroplethPower is not defined!");
            }
        } else {

            if(powerChoroplethLayer) {
                map.removeLayer(powerChoroplethLayer);
                powerChoroplethLayer = null;
            }

            let filteredForPlot = powerData.slice();
            if (selectedState !== "all") filteredForPlot = filteredForPlot.filter(p => p.state === selectedState);
            if (selectedFuel !== "all") filteredForPlot = filteredForPlot.filter(p => p.primary_fuel === selectedFuel);
            if (selectedSubbasin !== "all") filteredForPlot = filteredForPlot.filter(p => p.subbasin === selectedSubbasin);

            clearPowerLayer();
            const maxPower = Math.max(...filteredForPlot.map(p => parseFloat(p.total_mwh) || 1));

            powerMarkers = [];
filteredForPlot.forEach(p => {
    const raw = parseFloat(p.total_mwh) || 0;
    const intensity = Math.min(raw / maxPower, 1);

    // Color can still depend on intensity (optional)
    let color;
    if (intensity < 0.2) color = '#FFF3BF';
    else if (intensity < 0.4) color = '#FFD580';
    else if (intensity < 0.6) color = '#FFA500';
    else if (intensity < 0.8) color = '#FF6A00';
    else color = '#FF0000';

    const marker = L.circleMarker([p.lat, p.lon], {
        radius: 5,           // constant size for all markers
        fillColor: color,
        color: color,
        fillOpacity: 0.6,
        weight: 1
    }).addTo(map);

    marker.bindTooltip(
        `Power: ${raw.toLocaleString()} MWh\nSubbasin: ${p.subbasin}\nFuel: ${p.primary_fuel}`,
        { direction:'top', className:'aqi-tooltip' }
    );

    powerMarkers.push({ marker, intensity });
});

        }

        // ------------------------------------------------------------
        // üåü 4. Dropdown logic (unchanged)
        // ------------------------------------------------------------
        const filteredStates = [...new Set(
            powerData
                .filter(p => (selectedFuel === "all" || p.primary_fuel === selectedFuel) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                .map(p => p.state).filter(Boolean)
        )].sort();

        const filteredFuels = [...new Set(
            powerData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                .map(p => p.primary_fuel).filter(Boolean)
        )].sort();

        const filteredSubbasins = [...new Set(
            powerData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedFuel === "all" || p.primary_fuel === selectedFuel))
                .map(p => p.subbasin).filter(Boolean)
        )].sort();

        // dropdown population omitted for brevity (unchanged)...

        document.getElementById('footer-timestamp').innerText =
            `Updated: ${new Date(data.timestamp).toLocaleString()}`;

        setLegend('power');

    } catch (err) {
        console.error('Error loading power heatmap:', err);
    }
}

// New Global Variable for Carbon Choropleth
let carbonChoroplethLayer = null;

// New Color Helper for Carbon (using CO2 layer color scheme)
function getChoroplethCarbonColor(carbonValue, maxCarbon) {
    if (maxCarbon === 0) return '#E0E7FF';

    // Normalize intensity (0 to 1)
    const intensity = carbonValue / maxCarbon;

    // Use Carbon layer's color scheme (light orange -> dark red)
    if (intensity < 0.2) return '#FFD580';       // light orange
    else if (intensity < 0.4) return '#FFA500';  // orange
    else if (intensity < 0.6) return '#FF6A00';  // deep orange
    else if (intensity < 0.8) return '#FF0000';  // red
    else return '#8B0000';                         // dark red / maroon
}

// New Choropleth Renderer for Carbon (based on Power/Water logic)
async function renderStateChoroplethCarbon(carbonData, maxCarbon) {
    if (carbonChoroplethLayer) {
        map.removeLayer(carbonChoroplethLayer);
        carbonChoroplethLayer = null;
    }

    try {
        // Fetch US state GeoJSON data (assuming US_STATES_GEOJSON_URL is defined globally)
        const res = await fetch(US_STATES_GEOJSON_URL);
        if (!res.ok) throw new Error(`Failed to load GeoJSON: ${res.status}`);
        const geojsonData = await res.json();

        function getDataKey(geojsonName) {
            // Assumes stateAbbreviations is defined globally
            return stateAbbreviations[geojsonName];
        }

        function styleFeature(feature) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgCarbon = carbonData[dataKey] || 0;

            return {
                fillColor: getChoroplethCarbonColor(avgCarbon, maxCarbon),
                weight: 1.5,
                opacity: 1,
                color: 'white',
                fillOpacity: avgCarbon > 0 ? 0.75 : 0.4
            };
        }

        function onEachFeature(feature, layer) {
            const geojsonName = feature.properties.name;
            const dataKey = getDataKey(geojsonName);
            const avgCarbon = carbonData[dataKey];

            let tooltipText = `<strong>${geojsonName} (${dataKey || 'N/A'})</strong><br>`;
            tooltipText += avgCarbon ?
                           `Avg. CO‚ÇÇ: ${avgCarbon.toFixed(2)} kg/MWh` :
                           `No facility data available.`;

            layer.bindTooltip(tooltipText, { sticky: true, direction: 'center' });

            layer.on({
                mouseover: (e) => { e.target.setStyle({ weight: 3, color: '#666', fillOpacity: 0.9 }); },
                mouseout: (e) => { carbonChoroplethLayer.resetStyle(e.target); },
            });
        }

        // Create and add the GeoJSON layer to the map
        carbonChoroplethLayer = L.geoJson(geojsonData, {
            style: styleFeature,
            onEachFeature: onEachFeature
        }).addTo(map);

    } catch (error) {
        console.error("Error rendering Carbon choropleth map:", error);
    }
}

// Dedicated clearing function for Carbon layer
function clearCarbonLayer() {
    // Remove markers
    if (carbonMarkers && carbonMarkers.length > 0) {
        carbonMarkers.forEach(m => map.removeLayer(m));
        carbonMarkers = [];
    }
    // Remove choropleth
    if (carbonChoroplethLayer) {
        map.removeLayer(carbonChoroplethLayer);
        carbonChoroplethLayer = null;
    }
    // Remove heatmap if used for base layer
    // if (carbonHeatLayer) { map.removeLayer(carbonHeatLayer); carbonHeatLayer = null; }
}

// Function: clearHeatLayer() (This ensures all layers are gone on *any* switch)
function clearHeatLayer() {
    if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }
    if (aqiMarkers.length > 0) {
        aqiMarkers.forEach(m => map.removeLayer(m));
        aqiMarkers = [];
    }
    clearAQILayer();
    // Clear all specific layers (markers, heatmaps, AND choropleths)
    clearWaterLayer(); // Clears water markers and choroplethLayer
    clearPowerLayer(); // Clears power markers and powerChoroplethLayer
    clearCarbonLayer();
    // Explicitly call the Carbon clear function
    if (typeof clearCarbonLayer === 'function') {
        clearCarbonLayer();
    } else {
        // Fallback explicit clear for carbon if clearCarbonLayer DNE
        if (carbonMarkers && carbonMarkers.length > 0) {
            carbonMarkers.forEach(m => map.removeLayer(m));
            carbonMarkers = [];
        }
        if (carbonChoroplethLayer) {
            map.removeLayer(carbonChoroplethLayer);
            carbonChoroplethLayer = null;
        }
    }

    document.getElementById('footer-timestamp').innerText = "Data layer not implemented yet";
    setLegend(""); // clear legend
}


        async function loadCarbonHeatmap(selectedState = "all", selectedFuel = "all", selectedSubbasin = "all", aggregationLevel = "point") {
    try {
        const res = await fetch('https://data-center-map-nu1d.onrender.com/api/carbon');
        const data = await res.json();
        let carbonData = data.points || [];
        if (!carbonData.length) return;

        // ------------------------------------------------------------
        // üåü 1. Apply filters BEFORE aggregation
        // ------------------------------------------------------------
        let filteredData = carbonData.slice();
        if (selectedState !== "all") filteredData = filteredData.filter(p => p.state === selectedState);
        if (selectedFuel !== "all") filteredData = filteredData.filter(p => p.primary_fuel === selectedFuel);
        if (selectedSubbasin !== "all") filteredData = filteredData.filter(p => p.subbasin === selectedSubbasin);

        // ------------------------------------------------------------
        // üåü 2. STATE-LEVEL AGGREGATION
        // ------------------------------------------------------------
        const stateTotals = {};
        filteredData.forEach(p => {
            const state = p.state;
            const footprint = parseFloat(p.carbon_footprint) || 0;
            if (state) {
                if (!stateTotals[state]) {
                    stateTotals[state] = { totalFootprint: 0, count: 0 };
                }
                stateTotals[state].totalFootprint += footprint;
                stateTotals[state].count += 1;
            }
        });

        // Calculate average footprint for choropleth plotting
        let stateDataForChoropleth = {};
        let allAvgs = [];

        for (const state in stateTotals) {
            const avg = stateTotals[state].totalFootprint / stateTotals[state].count;
            stateDataForChoropleth[state] = avg;
            allAvgs.push(avg);
        }

        // Max carbon footprint across the filtered/aggregated data
        const maxCarbonAgg = Math.max(...allAvgs, 0);

        // --- Clear ALL layers for this theme before plotting ---
        // (Assumes clearCarbonLayer handles carbonMarkers and carbonChoroplethLayer cleanup)
        if (typeof clearCarbonLayer === 'function') {
             clearCarbonLayer();
        } else {
             console.error("clearCarbonLayer function is not defined! Cannot ensure complete layer cleanup.");
        }


        // ------------------------------------------------------------
        // üåü 3. PLOTTING MODE (state choropleth vs point)
        // ------------------------------------------------------------
        if (aggregationLevel === "state") {
            // **A. CHOROPLETH PLOTTING**
            if (typeof renderStateChoroplethCarbon === "function") {
                // Use the aggregated average data and its max value
                renderStateChoroplethCarbon(stateDataForChoropleth, maxCarbonAgg);
            } else {
                console.error("renderStateChoroplethCarbon is not defined! Cannot draw state polygons.");
            }
        } else {
            // --- POINT PLOTTING (Original Marker Logic) ---
let filteredForPlot = filteredData;
if (!filteredForPlot.length) return;

// Optional: keep color gradient based on normalized footprint
const maxCarbonPoint = Math.max(...filteredForPlot.map(p => parseFloat(p.carbon_footprint) || 1));

filteredForPlot.forEach(p => {
    const raw = parseFloat(p.carbon_footprint) || 0;
    const normalized = Math.min(raw / maxCarbonPoint, 1);

    // Color gradient (optional)
    let color;
    if (normalized < 0.2) color = '#FFD580';
    else if (normalized < 0.4) color = '#FFA500';
    else if (normalized < 0.6) color = '#FF6A00';
    else if (normalized < 0.8) color = '#FF0000';
    else color = '#8B0000';

    // --- Fixed marker radius ---
    const marker = L.circleMarker([p.lat, p.lon], {
        radius: 5,           // constant size
        fillColor: color,
        color: color,
        fillOpacity: 0.8,
        weight: 0.5
    }).addTo(map)
    .bindTooltip(
        `CO‚ÇÇ: ${raw.toLocaleString()} kg/MWh\nSubbasin: ${p.subbasin}\nFuel: ${p.primary_fuel}`,
        { direction: 'top', className: 'aqi-tooltip' }
    );

    carbonMarkers.push(marker);
});

        }


        // ------------------------------------------------------------
        // üåü 4. Dropdown Population Logic (Original Code)
        // ------------------------------------------------------------

        // --- Compute allowed values for dropdowns based on other selections ---
        const filteredStates = [...new Set(
            carbonData
                .filter(p => (selectedFuel === "all" || p.primary_fuel === selectedFuel) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                        .map(p => p.state).filter(Boolean)
        )].sort();

        const filteredFuels = [...new Set(
            carbonData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedSubbasin === "all" || p.subbasin === selectedSubbasin))
                        .map(p => p.primary_fuel).filter(Boolean)
        )].sort();

        const filteredSubbasins = [...new Set(
            carbonData
                .filter(p => (selectedState === "all" || p.state === selectedState) &&
                             (selectedFuel === "all" || p.primary_fuel === selectedFuel))
                        .map(p => p.subbasin).filter(Boolean)
        )].sort();

        // --- Populate STATE DROPDOWN ---
        const stateSelect = document.getElementById('state-filter');
        if (stateSelect) {
            stateSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'All States';
            allOption.selected = selectedState === 'all';
            stateSelect.appendChild(allOption);

            filteredStates.forEach(s => {
                const option = document.createElement('option');
                option.value = s;
                option.text = s;
                if (s === selectedState) option.selected = true;
                stateSelect.appendChild(option);
            });
            stateSelect.size = 1;
        }

        // --- Populate FUEL DROPDOWN ---
        const fuelSelect = document.getElementById('fuel-filter');
        if (fuelSelect) {
            fuelSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'All Fuels';
            allOption.selected = selectedFuel === 'all';
            fuelSelect.appendChild(allOption);

            filteredFuels.forEach(f => {
                const option = document.createElement('option');
                option.value = f;
                option.text = f;
                if (f === selectedFuel) option.selected = true;
                fuelSelect.appendChild(option);
            });
            fuelSelect.size = 1;
        }

        // --- Populate SUBBASIN DROPDOWN ---
        const subbasinSelect = document.getElementById('subbasin-filter');
        if (subbasinSelect) {
            subbasinSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.text = 'PCAs';
            allOption.selected = selectedSubbasin === 'all';
            subbasinSelect.appendChild(allOption);

            filteredSubbasins.forEach(sb => {
                const option = document.createElement('option');
                option.value = sb;
                option.text = sb;
                if (sb === selectedSubbasin) option.selected = true;
                subbasinSelect.appendChild(option);
            });
            subbasinSelect.size = 1;
        }


        document.getElementById('footer-timestamp').innerText =
            `Updated: ${new Date(data.timestamp).toLocaleString()}`;

        setLegend('co2');

    } catch(err) {
        console.error('Error loading carbon heatmap:', err);
    }
}


        // Track currently active layer
        let activeLayer = 'water'; // default

        // Helper to get current selected values from all dropdowns
        function getFilterValues() {
            const stateSelect = document.getElementById('state-filter');
            const fuelSelect = document.getElementById('fuel-filter');
            const subbasinSelect = document.getElementById('subbasin-filter');

            return {
                state: stateSelect ? stateSelect.value : 'all',
                fuel: fuelSelect ? fuelSelect.value : 'all',
                subbasin: subbasinSelect ? subbasinSelect.value : 'all'
            };
        }

        // Helper to get current aggregation level
        function getAggregationLevel() {
            const aggSelect = document.getElementById('aggregation-filter');
            return aggSelect ? aggSelect.value : 'point';
        }

        // --- Event listeners for all filters (FIXED for Power and CO2) ---
['state-filter', 'fuel-filter', 'subbasin-filter'].forEach(id => {
    const select = document.getElementById(id);
    if (select) {
        select.addEventListener('change', async () => {
            const { state, fuel, subbasin } = getFilterValues();
            const aggregationLevel = getAggregationLevel(); // Get current aggregation setting

            // When filter changes, reload heatmap using current aggregation level
            if (currentLayer === 'water') {
                await loadWaterHeatmap(state, fuel, subbasin, aggregationLevel);
            } else if (currentLayer === 'power') {
                // ‚úÖ FIX: Pass aggregationLevel to power layer
                await loadPowerHeatmap(state, fuel, subbasin, aggregationLevel);
            } else if (currentLayer === 'co2') {
                // Needs to be fixed here too to align with other fix!
                await loadCarbonHeatmap(state, fuel, subbasin, aggregationLevel);
            }
        });
    }
});

        async function loadDataCenterSummary() {
            // 1. Hide all map-related panels and filters
            hideMapControls();

            // 2. FIX: ONLY MAKE THE OVERLAY VISIBLE. DO NOT RESET innerHTML.
            // This preserves the permanent canvas elements in the DOM.
            const summaryOverlay = document.getElementById('summary-overlay');
            if (summaryOverlay) {
                summaryOverlay.style.display = 'block';
            }

            // 3. Destroy previous chart instances
            if (window.plotStatusChart) window.plotStatusChart.destroy();
            if (window.plotStatesChart) window.plotStatesChart.destroy();
            if (window.plotOperatorsChart) window.plotOperatorsChart.destroy();
            if (window.plotSizeChart) window.plotSizeChart.destroy();

            try {
                const res = await fetch('https://data-center-map-nu1d.onrender.com/api/data_center_summary');
                const data = await res.json();

                // ----------------------------------------------------
                // üåü ENHANCEMENT: Implement robust data validation üåü
                // ----------------------------------------------------
                const status_counts = Array.isArray(data.status_counts) ? data.status_counts : [];
                const top_states = Array.isArray(data.top_states) ? data.top_states : [];
                const top_operators = Array.isArray(data.top_operators) ? data.top_operators : [];
                const size_distribution = Array.isArray(data.size_distribution) ? data.size_distribution : [];

                // --- Plot 1: Project Status Donut (FIXED STRETCHING) ---
                if (status_counts.length > 0) {
                    window.plotStatusChart = new Chart(document.getElementById('plot-status').getContext('2d'), {
                        type: 'doughnut',
                        data: {
                            labels: status_counts.map(d => d.Count),
                            datasets: [{
                                data: status_counts.map(d => d.count),
                                backgroundColor: [
                                    '#7C83FD', // muted blue
                                    '#F7B267', // muted orange
                                    '#FFD166', // muted yellow
                                    '#70E3B1', // muted green
                                    '#5EC8E6', // muted cyan
                                    '#FF70A6'  // muted pink
                                ],
                                hoverBackgroundColor: [
                                    '#A3A3F7',
                                    '#F7B7A3',
                                    '#F7E3A3',
                                    '#A3F7BF',
                                    '#A3E7F7',
                                    '#F7A3C7'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 1,
                            plugins: {
                                legend: { position: 'bottom', labels: { color: '#fff' } },
                                title: { display:true, text:'Status of Data Centers in the US', color: '#fff' }
                            }
                        }
                    });
                    // Display total number of data centers
                    const totalCount = status_counts.reduce((sum, d) => sum + (typeof d.count === 'number' ? d.count : 0), 0);
                    document.getElementById('total-dc-count').innerText = `Total Data Centers: ${totalCount}`;
                } else {
                    document.getElementById('plot-status').parentElement.innerHTML = '<div class="grid-box" style="color:#fff; text-align:center;">No Status data available.</div>';
                }

                // --- Plot 2: Top States Horizontal Bar (MAINTAIN ASPECT RATIO SET) ---
                if (top_states.length > 0) {
                    window.plotStatesChart = new Chart(document.getElementById('plot-states').getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: top_states.map(d => d.Count),
                            datasets: [{
                                label: 'Facilities',
                                data: top_states.map(d => d.count),
                                backgroundColor: [
                                    '#7C83FD', '#F7B267', '#FFD166', '#70E3B1', '#5EC8E6',
                                    '#FF70A6', '#A3A3F7', '#F7B7A3', '#F7E3A3', '#A3F7BF'
                                ]
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false }, title: { display:true, text:'States with Most Data Centers', color: '#fff' } },
                            scales: {
                                x: {
                                    ticks: { color: '#fff' },
                                    title: { display: true, text: 'Number of Data Centers', color: '#fff', font: { size: 14 } },
                                    grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 }
                                },
                                y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 } }
                            }
                        }
                    });
                } else {
                    document.getElementById('plot-states').parentElement.innerHTML = '<div class="grid-box" style="color:#ccc; text-align:center;">No States data available.</div>';
                }

                // --- Plot 3: Top Operators Lollipop (MAINTAIN ASPECT RATIO SET) ---
                if (top_operators.length > 0) {
                    // Extract data once
                    const counts = top_operators.map(d => d.count);
                    const labels = top_operators.map(d => d.Count);

                    // Balanced color palette for lollipop sticks and balls
                    const balancedSticks = [
                        'rgba(124,131,253,0.45)', 'rgba(247,178,103,0.45)', 'rgba(255,209,102,0.45)',
                        'rgba(112,227,177,0.45)', 'rgba(94,200,230,0.45)', 'rgba(255,112,166,0.45)',
                        'rgba(163,163,247,0.45)', 'rgba(247,183,163,0.45)', 'rgba(247,227,163,0.45)', 'rgba(163,247,191,0.45)'
                    ];
                    const balancedBalls = [
                        '#7C83FD', '#F7B267', '#FFD166', '#70E3B1', '#5EC8E6',
                        '#FF70A6', '#A3A3F7', '#F7B7A3', '#F7E3A3', '#A3F7BF'
                    ];
                    window.plotOperatorsChart = new Chart(document.getElementById('plot-operators').getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Facilities',
                                data: counts,
                                backgroundColor: balancedSticks,
                                borderColor: 'transparent',
                                borderWidth: 0,
                                barPercentage: 0.2,
                                categoryPercentage: 0.8,
                                borderRadius: 0,
                            }, {
                                label: 'Marker',
                                data: counts,
                                type: 'scatter',
                                pointRadius: 7,
                                pointBackgroundColor: balancedBalls,
                                pointBorderColor: '#fff',
                                pointBorderWidth: 2,
                                pointStyle: 'circle',
                                order: 0,
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            layout: {
                                padding: { right: 10 }
                            },
                            plugins: {
                                legend: { display:false },
                                title: { display:true, text:'Top 10 Data Center Operators in the US', color: '#fff' }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: { color: '#fff' },
                                    title: { display: true, text: 'Number of Data Centers', color: '#fff', font: { size: 14 } },
                                    grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 }
                                },
                                y: {
                                    ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 }
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('plot-operators').parentElement.innerHTML = '<div class="grid-box" style="color:#ccc; text-align:center;">No Operators data available.</div>';
                }

                // --- Plot 4: Facility Size Distribution (Density Curve Plot) ---
                if (size_distribution.length > 0) {
                    // 1. Extract ALL size data (raw values)
                    const rawSizeData = size_distribution
                        .map(d => parseFloat(d.Size_Million_sq_ft))
                        .filter(n => !isNaN(n) && n > 0);

                    if (rawSizeData.length > 0) {
                        // --- Step 1: Create Bins and Normalized Frequency Data Points ---
                        const totalCount = rawSizeData.length;
                        const minSize = Math.min(...rawSizeData);
                        const maxSize = Math.max(...rawSizeData);
                        const numBins = 15;
                        const binWidth = (maxSize - minSize) / numBins;

                        const bins = Array(numBins).fill(0);
                        const curvePoints = [];

                        rawSizeData.forEach(size => {
                            let binIndex = Math.floor((size - minSize) / binWidth);
                            if (binIndex >= numBins) binIndex = numBins - 1;
                            bins[binIndex]++;
                        });

                        for (let i = 0; i < numBins; i++) {
                            const center = minSize + (i + 0.5) * binWidth;
                            const normalizedFrequency = bins[i] / totalCount;
                            curvePoints.push({ x: center, y: normalizedFrequency });
                        }

                        // --- Step 2: Chart Configuration ---
                        if (window.plotSizeChart) window.plotSizeChart.destroy();

                        window.plotSizeChart = new Chart(document.getElementById('plot-size').getContext('2d'), {
                            type: 'line',
                            data: {
                                datasets: [
                                    {
                                        label: 'Distribution Density',
                                        data: curvePoints,
                                        type: 'line',
                                        xAxisID: 'x-linear',
                                        yAxisID: 'density-axis',
                                        borderColor: '#6EC1E4',
                                        backgroundColor: 'rgba(110, 193, 228, 0.4)',
                                        borderWidth: 3,
                                        fill: true,
                                        tension: 0.4,
                                        pointRadius: 0,
                                        showLine: true
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'nearest',
                                    intersect: false,
                                    axis: 'x'
                                },
                                plugins: {
                                    legend: { display: false },
                                    title: { display: true, text: 'Data Center Size Distribution', color: '#fff' },
                                    tooltip: {
                                        callbacks: {
                                            title: function(context) {
                                                return `Size: ${context[0].parsed.x.toFixed(2)} Million sq ft`;
                                            },
                                            label: function(context) {
                                                return `Density: ${context.parsed.y.toFixed(3)}`;
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    'x-linear': {
                                        type: 'linear',
                                        position: 'bottom',
                                        title: { display: true, text: 'Size (Million sq ft)', color: '#fff' },
                                        min: minSize,
                                        max: maxSize,
                                        ticks: { color: '#fff' },
                                        grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 }
                                    },
                                    'density-axis': {
                                        type: 'linear',
                                        position: 'left',
                                        beginAtZero: true,
                                        max: Math.max(...curvePoints.map(p => p.y)) * 1.2 || 1.0,
                                        title: { display: true, text: 'Normalized Density', color: '#6EC1E4' },
                                        grid: { color: 'rgba(255,255,255,0.18)', lineWidth: 1 },
                                        ticks: { color: '#6EC1E4' }
                                    }
                                }
                            }
                        });
                    } else {
                        document.getElementById('plot-size').parentElement.innerHTML = '<div class="grid-box" style="color:#ccc; text-align:center;">No valid Size data available for plotting.</div>';
                    }
                } else {
                    document.getElementById('plot-size').parentElement.innerHTML = '<div class="grid-box" style="color:#ccc; text-align:center;">No Size data available.</div>';
                }

                console.log("Data Center Summary loaded.");
            } catch(e) {
                console.error("Failed to fetch data center summary:", e);
                // This fallback catches API server issues (HTTP 500, fetch error)
                document.getElementById('summary-overlay').innerHTML = '<div style="color:#FF6B6B; text-align:center; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); font-size:1.5rem; background:rgba(0,0,0,0.8); padding:20px; border-radius:10px;">Failed to load data center summary data. Check API service endpoint (http://127.0.0.1:3000/api/data_center_summary).</div>';
            }
        }


        // --- Initial Load ---
        // Do not load carbon heatmap automatically
        loadDataCenters();  // always fine
        loadAQIHeatmap();    // initial view is AQI only
        document.getElementById('carbon-projection-modal').style.display = 'none';


        // --- Monitor layer radio ---
        document.getElementsByName("monitor-layer").forEach(radio=>{
            radio.addEventListener('change', ()=>{
                const label = radio.parentElement.textContent.trim();
                currentPollutant = label.includes("Ozone only")?"ozone":label.includes("PM2.5")?"pm":"all";
                if(currentLayer==="air") loadAQIHeatmap();
            });
        });

        // --- Nav ribbon (refactored) ---
        const panels = {
            monitor: document.getElementById('monitor-panel'),
            insights: document.getElementById('more-insights'),
        };

        const filterIds = ['state-filter', 'fuel-filter', 'subbasin-filter'];

        function toggleFiltersForLayer(layer) {
            const show = ['water','power','co2'].includes(layer.toLowerCase());
            filterIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = show ? 'block' : 'none';
            });
        }

        function showPanelsFor(layer) {
            // Toggle main panels
            panels.monitor.style.display = (layer === "air") ? "flex" : "none";
            panels.insights.style.display = (layer === "water" || layer === "co2") ? "flex" : "none";

            // Toggle the map info text box
            const infoBox = document.getElementById('map-info-box');
            if (infoBox) {
                infoBox.style.display = (layer === "air") ? "block" : "none";
            }

            // Remove old projection tabs if they exist
            const projectionTabIds = [
                'water-projection-tab',
                'water-vs-carbon-tab',
                'carbon-projection-tab'
            ];

            projectionTabIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });

            // Add relevant projection tabs
            if (layer === "water") {
                addWaterProjectionTab();
                // addWaterVsCarbonTab(); // NEW
            }
            if (layer === "co2") {
                addCarbonProjectionTab();
            }

            // --- Toggle filters for this layer ---
            toggleFiltersForLayer(layer);
        }


        function clearWaterLayer() {
    // üåü FIX: Explicitly and immediately remove choropleth layer üåü
    if (choroplethLayer) {
        map.removeLayer(choroplethLayer);
        choroplethLayer = null;
    }
    // Remove heatmap (if ever used)
    if (waterHeatLayer) {
        map.removeLayer(waterHeatLayer);
        waterHeatLayer = null;
    }
    // Remove markers
    if (waterMarkers && waterMarkers.length > 0) {
        waterMarkers.forEach(obj => map.removeLayer(obj.circle));
        waterMarkers = [];
    }

    // Clear animation
    if (waterPulseInterval) {
        clearInterval(waterPulseInterval);
        waterPulseInterval = null;
    }
}

        function clearPowerLayer() {
    // üåü FIX: Explicitly and immediately remove choropleth layer üåü
    if(powerChoroplethLayer) {
        map.removeLayer(powerChoroplethLayer);
        powerChoroplethLayer = null;
    }
    // Clear heat layer
    if(powerHeatLayer) {
        map.removeLayer(powerHeatLayer);
        powerHeatLayer = null;
    }
    // Clear markers
    if(powerMarkers && powerMarkers.length > 0){
        powerMarkers.forEach(obj => map.removeLayer(obj.marker));
        powerMarkers = [];
    }
    if(powerPulseInterval){
        clearInterval(powerPulseInterval);
        powerPulseInterval = null;
    }
}

        function addWaterProjectionTab() {
            // Remove existing tab if already present
            const existingTab = document.getElementById('water-projection-tab');
            if(existingTab) existingTab.remove();

            const tab = document.createElement('div');
            tab.id = 'water-projection-tab';
            tab.className = 'insight-item';
            tab.innerHTML = '<i class="fas fa-water" style="color:#3B82F6;"></i> Water Projections';
            tab.style.cursor = 'pointer';

            tab.addEventListener('click', () => {
                document.getElementById('water-projection-modal').style.display = 'flex';
                loadWaterProjectionChart();
            });

            document.getElementById('more-insights').appendChild(tab);
        }

        // --- NEW: Water vs Carbon Chart ---
        function addWaterVsCarbonTab() {
            const existingTab = document.getElementById('water-vs-carbon-tab');
            if(existingTab) existingTab.remove();

            const tab = document.createElement('div');
            tab.id = 'water-vs-carbon-tab';
            tab.className = 'insight-item';
            tab.innerHTML = '<i class="fas fa-chart-line" style="color:#22C55E;"></i> Water vs Carbon Chart';
            tab.style.cursor = 'pointer';

            tab.addEventListener('click', () => {
                const panel = document.getElementById('insight-graph-panel');
                panel.style.display = 'flex';
                document.getElementById('graph-title').innerText = 'Water vs Power Tradeoff';
                loadWaterBubbleChart();
            });


            // Insert after Water Projection tab
            const waterTab = document.getElementById('water-projection-tab');
            if(waterTab) waterTab.insertAdjacentElement('afterend', tab);
            else document.getElementById('more-insights').appendChild(tab);
        }

        function addCarbonProjectionTab() {
            // Remove existing tab if already present
            const existingTab = document.getElementById('carbon-projection-tab');
            if(existingTab) existingTab.remove();

            const tab = document.createElement('div');
            tab.id = 'carbon-projection-tab';
            tab.className = 'insight-item';
            tab.innerHTML = '<i class="fas fa-cloud" style="color:red;"></i> Carbon Projections';
            tab.style.cursor = 'pointer';

            tab.addEventListener('click', () => {
                const modal = document.getElementById('carbon-projection-modal');
                modal.style.display = 'flex';

                // Give the browser a tick to apply layout before drawing chart
                setTimeout(() => loadCarbonProjectionChart(), 50);
            });


            document.getElementById('more-insights').appendChild(tab);
        }


        function clearHeatLayer() {
            if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }

            // Clear water
            clearWaterLayer();
            clearCarbonLayer();
            clearAQILayer()
            // Clear carbon markers
            if (carbonMarkers && carbonMarkers.length > 0) {
                carbonMarkers.forEach(m => map.removeLayer(m));
                carbonMarkers = [];
            }

            // Clear AQI markers
            if (aqiMarkers.length > 0) {
                aqiMarkers.forEach(m => map.removeLayer(m));
                aqiMarkers = [];
            }

            // Clear power markers & heatmap
            clearPowerLayer();

            document.getElementById('footer-timestamp').innerText = "Data layer not implemented yet";
            setLegend(""); // clear legend
        }


        let carbonLoaded = false; // existing at top of script
        let powerLoaded = false;  // new flag for power layer

        function removeSummaryOverlay() {
            const overlay = document.getElementById("summary-overlay");
            if (overlay) overlay.remove();
        }
        // ---- Layer Switcher (FIXED) ----
function loadLayer(layer) {
    // 1. Clear ALL old layers first
    clearHeatLayer();

    // 2. Hide summary overlay if necessary
    if (layer !== "summary") {
        document.getElementById('summary-overlay').style.display = 'none';
        showMapControls();
    }

    // 3. Get the current aggregation setting from the dropdown
    const aggregationLevel = getAggregationLevel();

    // 4. Load the selected layer
    switch (layer) {
        case "water":
            loadWaterHeatmap("all", "all", "all", aggregationLevel);
            break;
        case "air":
            loadAQIHeatmap("all", aggregationLevel);
            break;
        case "co2":
            // Pass aggregationLevel
            loadCarbonHeatmap("all", "all", "all", aggregationLevel);
            break;
        case "power":
            // Pass aggregationLevel
            loadPowerHeatmap("all", "all", "all", aggregationLevel);
            break;
        case "summary":
            loadDataCenterSummary();
            break;
        default:
            // Already cleared above, just keep legend clear
            break;
    }
}

        function hideMapControls() {
            document.getElementById('monitor-panel').style.display = 'none';
            document.getElementById('more-insights').style.display = 'none';
            document.getElementById('map-info-box').style.display = 'none';
            document.getElementById('state-filter').style.display = 'none';
            document.getElementById('fuel-filter').style.display = 'none';
            document.getElementById('subbasin-filter').style.display = 'none';
            document.getElementById('dc-info-tab').style.display = 'none';
            document.getElementById('aggregation-filter').style.display = 'none';
        }

        function showMapControls() {
            // The filters visibility is now controlled *only* by showPanelsFor / toggleFiltersForLayer
            // This function is intentionally left empty to fix the bug where filters reappear on the 'air' layer.
        }


        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                // Highlight active item
                document.querySelector('.nav-item.active')?.classList.remove('active');
                item.classList.add('active');

                const layer = item.dataset.layer;
                currentLayer = layer;

                showPanelsFor(layer);

                // Clear previous heatmap & markers before loading new layer
                clearHeatLayer();

                loadLayer(layer);
            });
        });

        // --- More Insights click ---
        document.querySelectorAll('#more-insights .insight-item').forEach(item => {
            item.addEventListener('click', () => {
                if (currentLayer !== "water" && currentLayer !== "co2") return;  // allow CO2 too
                const panel = document.getElementById('insight-graph-panel');
                panel.style.display = 'flex';

                // Pass the layer type so loadFuelTypeGraph knows which API to call
                loadFuelTypeGraph(currentLayer);
            });
        });


        // --- Close Graph Panel ---
        document.getElementById('close-graph-panel').addEventListener('click',()=>{
            document.getElementById('insight-graph-panel').style.display='none';
        });

        // Close Water Projections Modal
        document.getElementById('close-water-projection').addEventListener('click', () => {
            document.getElementById('water-projection-modal').style.display = 'none';
        });

        // Close Carbon Projections Modal
        document.getElementById('close-carbon-projection').addEventListener('click', () => {
            document.getElementById('carbon-projection-modal').style.display = 'none';
        });


        // --- DC Info Tab toggle ---
        const dcTab = document.getElementById('dc-info-tab');
        dcTab.addEventListener('click',()=>{
            if(dcTab.style.display==='none'||dcTab.style.display==='') dcTab.style.display='flex';
            dcTab.classList.toggle('large');
        });
        document.getElementById('close-dc-tab').addEventListener('click',e=>{
            e.stopPropagation();
            dcTab.classList.remove('large');
            dcTab.style.display='none';
        });

        async function loadFuelTypeGraph(layerType = "water") {
            try {
                // Decide which API to call based on layer
                const apiUrl = layerType === "co2"
                    ? 'https://data-center-map-nu1d.onrender.com/api/carbon_fuel'
                    : 'https://data-center-map-nu1d.onrender.com/api/water_fuel';

                const res = await fetch(apiUrl);
                const data = await res.json();

                const fuelMap = {};
                data.forEach(row => {
                    const fuel = row.primary_fuel || 'Unknown';
                    const value = layerType === "co2"
                        ? parseFloat(row.carbon_footprint) || 0
                        : parseFloat(row.water_footprint) || 0;

                    if (!fuelMap[fuel]) fuelMap[fuel] = 0;
                    fuelMap[fuel] += value;
                });

                const labels = Object.keys(fuelMap);
                const values = Object.values(fuelMap);

                const placeholder = document.getElementById('graph-placeholder');
                document.getElementById('graph-title').innerText = 'Fuel Type Analysis';
                placeholder.innerHTML = '<canvas id="fuel-chart"></canvas>';

                const ctx = document.getElementById('fuel-chart').getContext('2d');

                if (window.fuelChart) window.fuelChart.destroy();

                window.fuelChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: layerType === "co2" ? 'Carbon Footprint (kg CO‚ÇÇ)' : 'Water Footprint (m¬≥)',
                            data: values,
                            backgroundColor: ['#FF0000','#FF8800','#FFFF00','#22C55E','#06B6D4','#3B82F6'],
                            borderColor: '#fff',
                            borderWidth: 1,
                            borderRadius: 6,
                            hoverBackgroundColor: ['#FF5555','#FFAA55','#FFFF88','#4ADE80','#22D3EE','#60A5FA'],
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: '#111827',
                                titleColor: '#6EC1E4',
                                bodyColor: '#fff',
                                titleFont: { weight: '600' }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#fff', callback: val => val >= 1e6 ? (val/1e6).toFixed(1)+'M' : val },
                                title: { display: true, text: layerType === "co2" ? 'Carbon (kg CO‚ÇÇ)' : 'Water (m¬≥)', color:'#fff' }
                            },
                            x: { ticks: { color: '#fff' } }
                        }
                    }
                });
            } catch (err) {
                console.error('Error loading fuel type graph', err);
                document.getElementById('graph-placeholder').innerHTML =
                    '<div style="color:#ccc; text-align:center;">Failed to load chart.</div>';
            }
        }


        async function loadWaterProjectionChart() {
            try {
                const res = await fetch('https://data-center-map-nu1d.onrender.com/api/water_scenario');
                const data = await res.json();
                const points = data.points;
                console.log("Water Scenario API returned:", data);

                // --- Group points by year ---
                const yearMap = {};
                points.forEach(p => {
                    const year = p.year;
                    if (!yearMap[year]) yearMap[year] = { best: null, worst: null };
                    if (p.scenario.toLowerCase().includes("best")) yearMap[year].best = p.water_Mm3;
                    if (p.scenario.toLowerCase().includes("worst")) yearMap[year].worst = p.water_Mm3;
                });

                // Sort years
                const years = Object.keys(yearMap).sort((a, b) => a - b);

                // Create series arrays
                const bestSeries = years.map(y => yearMap[y].best ?? 0);
                const worstSeries = years.map(y => yearMap[y].worst ?? 0);

                // --- Render Chart.js line chart ---
                const ctx = document.getElementById('waterProjectionChart').getContext('2d');

                // Only destroy if it‚Äôs a Chart.js instance
                if (window.waterProjectionChart && window.waterProjectionChart instanceof Chart) {
                    window.waterProjectionChart.destroy();
                }


                window.waterProjectionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: years,
                        datasets: [
                            {
                                label: 'Best Water Projection',
                                data: bestSeries,
                                borderColor: 'green',
                                fill: false,
                                tension: 0.3
                            },
                            {
                                label: 'Worst Water Projection',
                                data: worstSeries,
                                borderColor: 'red',
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            tooltip: {
                                backgroundColor: '#111827',
                                titleColor: '#6EC1E4',
                                bodyColor: '#fff',
                                titleFont: { weight: '600' }
                            }
                        },
                        scales: {
                            x: { ticks: { color: '#fff' } },
                            y: {
                                ticks: { color: '#fff' },
                                title: { display: true, text: 'Water (Mm¬≥)', color: '#fff' }
                            }
                        }
                    }
                });

            } catch (err) {
                console.error('Error loading water projection chart', err);
            }
        }

        async function loadCarbonProjectionChart() {
            try {
                const res = await fetch('https://data-center-map-nu1d.onrender.com/api/carbon_scenario');
                const apiResponse = await res.json(); // 1. Renamed 'data' to 'apiResponse' for clarity
                console.log("Carbon Scenario API returned:", apiResponse); // Check this log!
                const points = apiResponse.data;

                // --- FIX: Add a guard clause here ---
                if (!points || !Array.isArray(points) || points.length === 0) {
                    console.error("Carbon data is missing or not an array:", data);
                    // Optional: Display a message in the modal instead of a chart
                    const chartContainer = document.getElementById('carbonProjectionChart').parentElement;
                    chartContainer.innerHTML = '<div style="flex:1; display:flex; align-items:center; justify-content:center; color:#ccc;">No Carbon Projection data available.</div>';
                    return; // Stop execution if data is bad or missing
                }

                // --- Group points by year ---
                const yearMap = {};
                points.forEach(p => {
                    const year = p.year;
                    if (!yearMap[year]) yearMap[year] = { best: null, worst: null };
                    if (p.scenario.toLowerCase().includes("best")) yearMap[year].best = p.carbon_MtCO2;
                    if (p.scenario.toLowerCase().includes("worst")) yearMap[year].worst = p.carbon_MtCO2;
                });

                // Sort years
                const years = Object.keys(yearMap).sort((a,b)=>a-b);

                // Create series arrays
                const bestSeries = years.map(y => yearMap[y].best ?? 0);
                const worstSeries = years.map(y => yearMap[y].worst ?? 0);

                // --- Render Chart.js line chart ---
                const ctx = document.getElementById('carbonProjectionChart').getContext('2d');

                // Only destroy if it‚Äôs a Chart.js instance
                if (window.carbonProjectionChart && window.carbonProjectionChart instanceof Chart) {
                    window.carbonProjectionChart.destroy();
                }

                window.carbonProjectionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: years,
                        datasets: [
                            {
                                label: 'Best Carbon Projection',
                                data: bestSeries,
                                borderColor: 'green',
                                fill: false,
                                tension: 0.3
                            },
                            {
                                label: 'Worst Carbon Projection',
                                data: worstSeries,
                                borderColor: 'red',
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,  // important for modal
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            tooltip: {
                                backgroundColor: '#111827',
                                titleColor: '#6EC1E4',
                                bodyColor: '#fff',
                                titleFont: { weight: '600' }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                ticks: {
                                    color: '#fff',
                                    font: { size: 12 },

                                },
                                title: {
                                    display: true,
                                    text: 'Year',
                                    color: '#fff',
                                    font: { size: 14 },
                                    padding: { top: 0, bottom: 5 }
                                }
                            },
                            y: {
                                display: true,
                                ticks: { color: '#fff' },
                                title: {
                                    display: true,
                                    text: 'Carbon (MtCO‚ÇÇ)',
                                    color: '#fff'
                                }
                            }
                        },
                        layout: {
                            padding: { bottom: 50}
                        }

                    }
                });

            } catch(err) {
                console.error('Error loading carbon projection chart', err);
            }
        }

        async function loadWaterBubbleChart() {
            try {
                const res = await fetch('https://data-center-map-nu1d.onrender.com/api/water_carbon_data');
                const data = await res.json();

                if (!data || data.length === 0) {
                    document.getElementById('graph-placeholder').innerHTML =
                        '<div style="color:#ccc; text-align:center;">No water/carbon data available.</div>';
                    return;
                }

                const maxWater = Math.max(...data.map(d => d.water_footprint));

                const chartData = data.map(d => ({
                    x: d.total_mwh,
                    y: d.scarcity_factor,
                    r: Math.sqrt((d.water_footprint / maxWater * 300) / Math.PI),
                    raw: d,  // keep full data for tooltip
                    backgroundColor: "rgba(50,50,50,0.7)",
                    borderColor: "#fff",
                    borderWidth: 1
                }));

                const placeholder = document.getElementById('graph-placeholder');
                placeholder.style.width = '1200px';
                placeholder.style.height = '800px';
                placeholder.innerHTML = '<canvas id="water-bubble-chart"></canvas>';

                const ctx = document.getElementById('water-bubble-chart').getContext('2d');

                if (window.waterBubbleChart) window.waterBubbleChart.destroy();

                window.waterBubbleChart = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: '',
                            data: chartData
                        }]
                    },
                    options: {
                        responsive: true,

                        interaction: {
                            mode: 'nearest',
                            intersect: true
                        },

                        plugins: {
                            tooltip: {
                                title: () => '',
                                callbacks: {
                                    label: function(context) {
                                        const d = context.raw;
                                        return `Scarcity: ${d.scarcity_factor}\nMWh: ${d.total_mwh.toLocaleString()}`;
                                    }
                                }
                            }
                        },

                        scales: {
                            x: {
                                type: 'linear',
                                min: 0,
                                max: 2.1e7,
                                title: { display: true, text: 'Electricity used by data centers (MWh)', color: '#fff' },
                                ticks: { color: '#fff' }
                            },
                            y: {
                                min: 0,
                                max: 105,
                                title: { display: true, text: 'Water scarcity factor', color: '#fff' },
                                ticks: { color: '#fff' }
                            }
                        }
                    }
                });

            } catch (err) {
                console.error(err);
                document.getElementById('graph-placeholder').innerHTML =
                    '<div style="color:#ccc; text-align:center;">Failed to load chart.</div>';
            }
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let defaultLayer = 'air'; // or 'water', 'co2', etc.
            showPanelsFor(defaultLayer); // hides filters if default is 'air'
        });
    </script>
</body>
</html>
